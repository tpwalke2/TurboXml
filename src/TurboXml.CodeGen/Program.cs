using System.Runtime.CompilerServices;
using System.Text;

namespace TurboXml.CodeGen;

internal class Program
{
    [Flags]
    internal enum XmlCharCategory : byte
    {
        None = 0,
        Char = 1 << 0,
        NameStartChar = 1 << 1,
        NameChar = 1 << 2,
        AttrValueChar = 1 << 3,
        CommentChar = 1 << 4,
        WhiteSpace = 1 << 5,
        CDATAChar = 1 << 6,
    }



    static void Main(string[] args)
    {
        var builder = new StringBuilder();
        builder.AppendLine(
            """
            //------------------------------------------------------------------------------
            // <auto-generated>
            // This code was generated by a TurboXml.CodeGen.
            //
            // Changes to this file may cause incorrect behavior and will be lost if
            // the code is regenerated.
            // </auto-generated>
            //
            // Copyright (c) Alexandre Mutel. All rights reserved.
            // Licensed under the BSD-Clause 2 license.
            // See license.txt file in the project root for full license information.
            //------------------------------------------------------------------------------
            """
        );
        builder.AppendLine();
        builder.AppendLine("using System;");
        builder.AppendLine();
        builder.AppendLine("namespace TurboXml;");
        builder.AppendLine();
        builder.AppendLine("internal static partial class XmlChar");
        builder.AppendLine("{");
        builder.AppendLine("    private static ReadOnlySpan<byte> CharCategories =>");
        builder.AppendLine("    [");
        builder.AppendLine("        //            0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    A,    B,    C,    D,    E,    F");
        for (int i = 0; i < 0x10000; i++)
        {
            if (i % 16 == 0)
            {
                builder.Append($"        /* {i:X4} */ ");
            }

            var rune = Unsafe.BitCast<int, Rune>(i);
            bool isChar = IsChar(rune);
            bool isNewLineChar = rune.Value == '\n' || rune.Value == '\r';
            bool isSpecialChar = rune.Value == '<' || rune.Value == '&';

            bool isNameStart = IsNameStartChar(rune);
            bool isName = IsNameChar(rune);

            bool isAttrValue = isChar && !isSpecialChar && !isNewLineChar && rune.Value != '\'' && rune.Value != '"';
            bool isCDATAChar = isChar && rune.Value != ']' && !isNewLineChar;
            bool isComment = isChar && rune.Value != '-' && !isNewLineChar;

            bool isWhiteSpace = IsWhiteSpace(rune);

            var category = XmlCharCategory.None;
            if (isChar) category |= XmlCharCategory.Char;
            if (isNameStart) category |= XmlCharCategory.NameStartChar;
            if (isName) category |= XmlCharCategory.NameChar;
            if (isAttrValue) category |= XmlCharCategory.AttrValueChar;
            if (isComment) category |= XmlCharCategory.CommentChar;
            if (isWhiteSpace) category |= XmlCharCategory.WhiteSpace;
            if (isCDATAChar) category |= XmlCharCategory.CDATAChar;

            builder.Append($"0x{(byte)category:X2},");

            if (i % 16 == 15)
            {
                builder.AppendLine();
            }
            else
            {
                builder.Append(' ');
            }
        }

        builder.AppendLine("    ];");
        builder.AppendLine("}");

        var fileDirectory = Path.GetFullPath(Path.Combine(AppContext.BaseDirectory, "..", "..", "..", "..", "TurboXml"));
        if (!Directory.Exists(fileDirectory))
        {
            throw new DirectoryNotFoundException($"Directory not found {fileDirectory}");
        }

        var filePath = Path.Combine(fileDirectory, "XmlChar.Generated.cs");
        File.WriteAllText(filePath, builder.ToString());
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsNameStartChar(Rune rune)
    {
        // [4] NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]

        return RuneBetween(rune, 'A', 'Z')
               || RuneBetween(rune, 'a', 'z')
               || rune.Value == ':'
               || rune.Value == '_'
               || RuneBetween(rune, '\xC0', '\xD6')
               || RuneBetween(rune, '\xD8', '\xF6')
               || RuneBetween(rune, '\xF8', '\x2FF')
               || RuneBetween(rune, '\x370', '\x37D')
               || RuneBetween(rune, '\x37F', '\x1FFF')
               || RuneBetween(rune, '\x200C', '\x200D')
               || RuneBetween(rune, '\x2070', '\x218F')
               || RuneBetween(rune, '\x2C00', '\x2FEF')
               || RuneBetween(rune, '\x3001', '\xD7FF')
               || RuneBetween(rune, '\xF900', '\xFDCF')
               || RuneBetween(rune, '\xFDF0', '\xFFFD')
               || RuneBetween(rune, 0x10000, 0xEFFFF);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsWhiteSpace(Rune c)
    {
        return c.Value == ' ' || c.Value == '\t' || c.Value == '\n' || c.Value == '\r';
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsChar(Rune c)
    {
        // Without surrogate
        // [2]   	Char	   ::=   	#x9 | #xA | #xD | [#x20-#xD7FF] | [#xE000-#xFFFD] | [#x10000-#x10FFFF]	/* any Unicode character, excluding the surrogate blocks, FFFE, and FFFF. */
        return c.Value == 0x9 || c.Value == 0xA || c.Value == 0xD || RuneBetween(c, 0x20, 0xD7FF) || RuneBetween(c, 0xE000, 0xFFFD) || RuneBetween(c, 0x10000, 0x10FFFF);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static bool IsNameChar(Rune rune)
    {
        // [4a] NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
        return IsNameStartChar(rune)
               || RuneBetween(rune, '0', '9')
               || rune.Value == '.'
               || rune.Value == '-'
               || rune.Value == '\xB7'
               || RuneBetween(rune, '\x0300', '\x036f')
               || RuneBetween(rune, '\x203f', '\x2040');
    }

    public static bool IsHexDigit(Rune c)
    {
        // TODO: could be optimized with a lookup table
        return RuneBetween(c, '0', '9') || RuneBetween(c, 'A', 'F') || RuneBetween(c, 'a', 'f');
    }


    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static bool RuneBetween(Rune value, int min, int max) => (uint)(value.Value - min) <= (uint)(max - min);
}